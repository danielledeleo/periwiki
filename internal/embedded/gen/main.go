//go:build ignore

// Generator for embedded article metadata.
// Run via: go generate ./internal/embedded
package main

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"

	"golang.org/x/mod/modfile"
)

func main() {
	// Find repo root
	repoRoot, err := findRepoRoot(".")
	if err != nil {
		fmt.Fprintf(os.Stderr, "error finding repo root: %v\n", err)
		os.Exit(1)
	}

	// Parse go.mod for module path
	modData, err := os.ReadFile(filepath.Join(repoRoot, "go.mod"))
	if err != nil {
		fmt.Fprintf(os.Stderr, "error reading go.mod: %v\n", err)
		os.Exit(1)
	}
	modFile, err := modfile.Parse("go.mod", modData, nil)
	if err != nil {
		fmt.Fprintf(os.Stderr, "error parsing go.mod: %v\n", err)
		os.Exit(1)
	}

	// Get HEAD commit (best-effort â€” build works without git)
	commit := "unknown"
	if out, err := exec.Command("git", "-C", repoRoot, "rev-parse", "HEAD").Output(); err == nil {
		commit = strings.TrimSpace(string(out))
	} else {
		fmt.Fprintf(os.Stderr, "warning: could not determine git commit: %v\n", err)
	}

	// Build base URL (GitHub only for now, skip if no commit)
	var baseURL string
	if commit != "unknown" {
		baseURL = buildBaseURL(modFile.Module.Mod.Path, commit)
	}

	// Generate metadata file
	outputPath := filepath.Join(repoRoot, "internal", "embedded", "metadata_gen.go")
	if err := generateFile(outputPath, commit, baseURL); err != nil {
		fmt.Fprintf(os.Stderr, "error generating file: %v\n", err)
		os.Exit(1)
	}

	short := commit
	if len(short) > 12 {
		short = short[:12]
	}
	fmt.Printf("Generated %s (commit: %s)\n", outputPath, short)

	// Generate source tarball for AGPL compliance.
	// The binary embeds this so users can always obtain the corresponding source.
	// The filename includes the commit hash so a stale tarball from a previous
	// generate run cannot accidentally be embedded by a bare `go build`.
	embeddedDir := filepath.Join(repoRoot, "internal", "embedded")
	cleanStaleTarballs(embeddedDir)

	tarballName := fmt.Sprintf("source-%s.tar.gz", short)
	tarballPath := filepath.Join(embeddedDir, tarballName)
	if err := generateSourceTarball(repoRoot, tarballPath); err != nil {
		fmt.Fprintf(os.Stderr, "error generating source tarball: %v\n", err)
		os.Exit(1)
	}

	// Generate source.go with the commit-specific embed directive.
	sourcePath := filepath.Join(embeddedDir, "source_gen.go")
	if err := generateSourceFile(sourcePath, tarballName); err != nil {
		fmt.Fprintf(os.Stderr, "error generating source.go: %v\n", err)
		os.Exit(1)
	}

	if info, err := os.Stat(tarballPath); err == nil {
		fmt.Printf("Generated %s (%d KB)\n", tarballPath, info.Size()/1024)
	}
}

// cleanStaleTarballs removes any source-*.tar.gz and source_gen.go left from
// a previous run so a bare `go build` fails instead of embedding stale source.
func cleanStaleTarballs(dir string) {
	matches, _ := filepath.Glob(filepath.Join(dir, "source-*.tar.gz"))
	for _, m := range matches {
		os.Remove(m)
	}
	os.Remove(filepath.Join(dir, "source_gen.go"))
}

const sourceTmpl = `// Code generated by go generate; DO NOT EDIT.

package embedded

import _ "embed"

//go:embed {{.Tarball}}
var SourceTarball []byte
`

func generateSourceFile(outputPath, tarballName string) error {
	t, err := template.New("source").Parse(sourceTmpl)
	if err != nil {
		return err
	}
	f, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer f.Close()
	return t.Execute(f, map[string]string{"Tarball": tarballName})
}

func generateSourceTarball(repoRoot, outputPath string) error {
	cmd := exec.Command("git", "-C", repoRoot, "archive",
		"--format=tar.gz", "--prefix=periwiki/",
		"--worktree-attributes", // honour uncommitted .gitattributes (export-ignore)
		"-o", outputPath, "HEAD")
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

func findRepoRoot(start string) (string, error) {
	dir, err := filepath.Abs(start)
	if err != nil {
		return "", err
	}
	for {
		if _, err := os.Stat(filepath.Join(dir, ".git")); err == nil {
			return dir, nil
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			return "", fmt.Errorf(".git not found")
		}
		dir = parent
	}
}

func buildBaseURL(modulePath, commit string) string {
	// Only GitHub supported for now
	if strings.HasPrefix(modulePath, "github.com/") {
		return fmt.Sprintf("https://%s/blob/%s", modulePath, commit)
	}
	return ""
}

const tmpl = `// Code generated by go generate; DO NOT EDIT.

package embedded

// BuildCommit is the git commit hash at build time.
const BuildCommit = "{{.Commit}}"

// SourceBaseURL is the base URL for viewing source files.
// Empty if the forge couldn't be determined from go.mod.
const SourceBaseURL = "{{.BaseURL}}"
`

func generateFile(outputPath, commit, baseURL string) error {
	t, err := template.New("metadata").Parse(tmpl)
	if err != nil {
		return err
	}

	f, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer f.Close()

	return t.Execute(f, map[string]string{
		"Commit":  commit,
		"BaseURL": baseURL,
	})
}
